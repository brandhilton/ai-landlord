<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monopoly Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        /* Renamed #game-container to #game-board-and-controls-wrapper in HTML */
        /* This style block is now effectively for #game-board-and-controls-wrapper */
        #game-board-and-controls-wrapper {
            display: flex;
            flex-wrap: wrap; /* Allows game controls to wrap below board on smaller screens */
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            padding: 20px;
            border-radius: 8px;
            /* Removed margin-bottom here, gap will handle spacing */
            flex: 0 0 auto; /* Don't grow, don't shrink, size based on content */
        }
        #setup-screen, #game-screen {
            width: 100%;
            text-align: center;
        }
        #player-setup {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .player-input-group {
            margin-bottom: 10px;
        }
        #game-board {
            display: grid;
            grid-template-columns: repeat(11, 1fr);
            grid-template-rows: repeat(11, 1fr);
            width: 800px; /* Adjust as needed */
            height: 800px; /* Adjust as needed */
            border: 2px solid black;
            box-sizing: border-box;
            background-color: #e0e0e0;
            position: relative;
        }
        .board-space {
            border: 1px solid #aaa;
            background-color: #f9f9f9;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 0.7em;
            text-align: center;
            padding: 2px;
            box-sizing: border-box;
            position: relative;
            cursor: pointer; /* Indicate clickable */
        }
        .board-space.corner { background-color: #d0d0d0; }
        .board-space.top, .board-space.bottom { width: 100%; height: 100%; }
        .board-space.left, .board-space.right { width: 100%; height: 100%; }

        /* Specific board layout using grid-area (as before, but less reliant on it now) */
        /* The CSS grid-area properties are manually defined and assume the `board` array order.
           This loop just creates the divs for each board space */
        #go { grid-area: 11 / 11; }
        #mediterranean-avenue { grid-area: 11 / 10; }
        #community-chest1 { grid-area: 11 / 9; }
        #baltic-avenue { grid-area: 11 / 8; }
        #income-tax { grid-area: 11 / 7; }
        #reading-railroad { grid-area: 11 / 6; }
        #oriental-avenue { grid-area: 11 / 5; }
        #chance1 { grid-area: 11 / 4; }
        #vermont-avenue { grid-area: 11 / 3; }
        #connecticut-avenue { grid-area: 11 / 2; }
        #jail { grid-area: 11 / 1; }

        #st-charles-place { grid-area: 10 / 1; }
        #electric-company { grid-area: 9 / 1; }
        #states-avenue { grid-area: 8 / 1; }
        #virginia-avenue { grid-area: 7 / 1; }
        #pennsylvania-railroad { grid-area: 6 / 1; }
        #st-james-place { grid-area: 5 / 1; }
        #community-chest2 { grid-area: 4 / 1; }
        #tennessee-avenue { grid-area: 3 / 1; }
        #new-york-avenue { grid-area: 2 / 1; }

        #freeparking { grid-area: 1 / 1; }
        #kentucky-avenue { grid-area: 1 / 2; }
        #chance2 { grid-area: 1 / 3; }
        #indiana-avenue { grid-area: 1 / 4; }
        #illinois-avenue { grid-area: 1 / 5; }
        #b-o-railroad { grid-area: 1 / 6; }
        #atlantic-avenue { grid-area: 1 / 7; }
        #ventnor-avenue { grid-area: 1 / 8; }
        #water-works { grid-area: 1 / 9; }
        #marvin-gardens { grid-area: 1 / 10; }
        #gotojail { grid-area: 1 / 11; }

        #pacific-avenue { grid-area: 2 / 11; }
        #north-carolina-avenue { grid-area: 3 / 11; }
        #community-chest3 { grid-area: 4 / 11; }
        #pennsylvania-avenue { grid-area: 5 / 11; }
        #short-line { grid-area: 6 / 11; }
        #chance3 { grid-area: 7 / 11; }
        #park-place { grid-area: 8 / 11; }
        #luxury-tax { grid-area: 9 / 11; }
        #boardwalk { grid-area: 10 / 11; }


        .token {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 1px solid black;
            box-sizing: border-box;
            bottom: 5px; /* Adjust as needed */
            right: 5px; /* Adjust as needed */
        }
        .token.p0 { background-color: red; left: 5px; bottom: 5px; }
        .token.p1 { background-color: blue; left: 25px; bottom: 5px; }
        .token.p2 { background-color: green; left: 5px; bottom: 25px; }
        .token.p3 { background-color: yellow; left: 25px; bottom: 25px; }
        .token.p4 { background-color: purple; left: 45px; bottom: 5px; } /* For more players */
        .token.p5 { background-color: orange; left: 45px; bottom: 25px; } /* For more players */

        /* Positioning for tokens *actually in jail* (on space 10) */
        /* These override the default pX positions when applied */
        .token.in-jail-position.p0 { top: 5px; right: 5px; left: auto; bottom: auto; }
        .token.in-jail-position.p1 { top: 5px; right: 25px; left: auto; bottom: auto; }
        .token.in-jail-position.p2 { top: 25px; right: 5px; left: auto; bottom: auto; }
        .token.in-jail-position.p3 { top: 25px; right: 25px; left: auto; bottom: auto; }
        .token.in-jail-position.p4 { top: 5px; right: 45px; left: auto; bottom: auto; }
        .token.in-jail-position.p5 { top: 25px; right: 45px; left: auto; bottom: auto; }


        .property-color-bar {
            height: 10px;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        /* Property Colors */
        .brown { background-color: #8B4513; }
        .light-blue { background-color: #87CEEB; }
        .pink { background-color: #FF69B4; }
        .orange { background-color: #FFA500; }
        .red { background-color: #FF0000; }
        .yellow { background-color: #FFFF00; }
        .green { background-color: #008000; }
        .dark-blue { background-color: #00008B; }

        .space-name {
            font-weight: bold;
            font-size: 0.7em;
            margin-top: 5px;
        }
        .space-price {
            font-size: 0.7em;
            color: #555;
        }
        .space-owner {
            position: absolute;
            bottom: 2px;
            font-size: 0.6em;
            color: #333;
            width: 100%;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }
        .space-houses {
            position: absolute;
            top: 15px;
            right: 5px;
            font-size: 0.8em;
            color: green;
        }

        #game-controls {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            border-left: 1px solid #eee;
            min-width: 300px;
            box-sizing: border-box;
        }
        #current-player-display {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        #dice-display {
            font-size: 2em;
            margin-bottom: 10px;
        }
        .button-group button {
            padding: 10px 15px;
            font-size: 1em;
            cursor: pointer;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            transition: background-color 0.2s;
        }
        .button-group button:hover:not(:disabled) {
            background-color: #0056b3;
        }
        .button-group button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        #message-log {
            flex-basis: 100%;
            height: 150px;
            border: 1px solid #ccc;
            padding: 10px;
            overflow-y: scroll;
            background-color: #e9e9e9;
            font-size: 0.9em;
            border-radius: 5px;
        }
        #message-log div {
            margin-bottom: 5px;
        }
        .player-status {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            text-align: left;
            font-size: 0.9em;
        }
        .player-status.current {
            border-color: #007bff;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
        }
        .player-status h4 {
            margin-top: 0;
            margin-bottom: 5px;
            color: #333;
        }
        .player-status ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .player-status ul li {
            margin-bottom: 3px;
        }
        .player-list {
            margin-bottom: 20px; /* Keep margin-bottom for spacing within game-controls */
        }
        #property-actions, #jail-actions {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #property-actions button, #jail-actions button {
            width: 100%;
        }
        .action-select {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }

        /* NEW: Overall game layout container */
        #overall-game-layout {
            display: flex;
            flex-wrap: wrap; /* Allows columns to wrap on very small screens */
            justify-content: center; /* Centers the content horizontally */
            align-items: flex-start; /* Aligns items to the top */
            gap: 20px; /* Space between the main game content and debug controls */
            max-width: 1800px; /* Increased max-width to accommodate both side-by-side */
            width: 100%; /* Take full width available within body's centering */
        }

        /* NEW: Main game content (board, controls, player list, message log) */
        #main-game-content {
            display: flex;
            flex-direction: column; /* Stack children vertically */
            gap: 20px; /* Space between sections in this column */
            flex: 1; /* Allows it to grow/shrink */
            min-width: 1150px; /* Minimum width for this column */
            max-width: 1200px; /* Max width for this column */
        }

        /* Wrapper for game board and its immediate controls (now inside main-game-content) */
        #game-board-and-controls-wrapper {
            display: flex;
            flex-wrap: wrap; /* Allows game controls to wrap below board on smaller screens */
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            padding: 20px;
            border-radius: 8px;
            flex: 1; /* Allows it to take available space in main-game-content */
        }

        /* Debug Controls Styling */
        #debug-controls {
            margin-top: 0; /* Removed margin-top as gap handles spacing */
            padding: 20px;
            border: 1px solid #ddd;
            background-color: #fff;
            border-radius: 8px;
            flex: 0 0 350px; /* Fixed width, won't grow/shrink much */
            max-width: 400px; /* Cap its max width */
            min-width: 300px; /* Ensure it doesn't get too small */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #debug-controls h2 {
            margin-top: 0;
            color: #333;
        }
        #debug-controls > div { /* Inner debug control groups */
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            width: 100%;
        }
        #debug-controls .debug-group {
            border: 1px solid #eee;
            padding: 15px;
            border-radius: 5px;
            background-color: #f9f9f9;
            flex: 1; /* Allow groups to grow/shrink */
            min-width: 250px; /* Minimum width for each group */
            max-width: 350px; /* Max width for each group */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #debug-controls .debug-group h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #555;
        }
        #debug-controls .debug-group select,
        #debug-controls .debug-group input[type="number"] {
            margin-bottom: 10px;
            width: calc(100% - 16px); /* Adjust for padding */
        }
        #debug-controls .debug-group button {
            width: 100%;
            margin-top: 5px;
        }

        /* Property Info Modal Styles */
        #property-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none; /* Hidden by default */
        }

        #property-modal-content {
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            width: 90%;
            max-width: 400px;
            position: relative;
            text-align: left;
            font-size: 0.95em;
        }

        #property-modal-content h3 {
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.5em;
            color: #333;
        }

        #property-modal-content .color-bar {
            height: 15px;
            width: 100%;
            margin-bottom: 15px;
            border-radius: 3px;
        }

        #property-modal-content p {
            margin-bottom: 8px;
            line-height: 1.4;
        }

        #property-modal-content strong {
            color: #000;
        }

        #property-modal-content ul {
            list-style: none;
            padding: 0;
            margin: 10px 0;
            border-top: 1px dashed #eee;
            padding-top: 10px;
        }

        #property-modal-content ul li {
            margin-bottom: 5px;
        }

        #property-modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.8em;
            cursor: pointer;
            color: #888;
            border: none;
            background: none;
            padding: 0;
        }
        #property-modal-close:hover {
            color: #333;
        }
    </style>
</head>
<body>

    <div id="setup-screen">
        <h1>Monopoly Setup</h1>
        <div id="player-setup">
            <label for="num-players">Number of Players (2-6):</label>
            <input type="number" id="num-players" value="2" min="2" max="6">
            <div id="player-name-inputs"></div>
            <button id="start-game-btn">Start Game</button>
        </div>
    </div>

    <div id="game-screen" style="display: none;">
        <h1>Monopoly</h1>
        <!-- NEW: Overall game layout container -->
        <div id="overall-game-layout">
            <!-- NEW: Main game content (board, controls, player list, message log) -->
            <div id="main-game-content">
                <!-- Wrapper for game board and its immediate controls -->
                <div id="game-board-and-controls-wrapper">
                    <div id="game-board"></div>

                    <div id="game-controls">
                        <div id="current-player-display"></div>
                        <div id="dice-display">Dice: -</div>
                        <div class="button-group">
                            <button id="roll-dice-btn">Roll Dice</button>
                            <button id="end-turn-btn" disabled>End Turn</button>
                        </div>

                        <div id="property-actions" style="display: none;">
                            <h3>Property Actions</h3>
                            <button id="buy-property-btn" style="display: none;">Buy Property</button>
                            <button id="build-house-btn" style="display: none;">Build House</button>
                            <select id="mortgage-select" class="action-select" style="display: none;"></select>
                            <button id="mortgage-property-btn" style="display: none;">Mortgage Property</button>
                            <select id="unmortgage-select" class="action-select" style="display: none;"></select>
                            <button id="unmortgage-property-btn" style="display: none;">Unmortgage Property</button>
                            <select id="sell-house-select" class="action-select" style="display: none;"></select>
                            <button id="sell-house-btn" style="display: none;">Sell House</button>
                        </div>

                        <div id="jail-actions" style="display: none;">
                            <h3>Jail Actions</h3>
                            <button id="pay-bail-btn">Pay $50 Bail</button>
                            <button id="use-jail-card-btn">Use Get Out of Jail Free Card</button>
                        </div>
                    </div>
                </div>
                <!-- Player List Container (now a direct child of main-game-content, below board/controls) -->
                <div id="player-list-container"></div>
                <!-- Message Log (now a direct child of main-game-content, below player list) -->
                <div id="message-log"></div>
            </div>

            <!-- Debug Controls Section (now a sibling to main-game-content) -->
            <div id="debug-controls" style="display: none;">
                <h2>Debug Controls</h2>

                <div>
                    <!-- Move Player -->
                    <div class="debug-group">
                        <h4>Move Player</h4>
                        <select id="debug-move-player-select" class="action-select"></select>
                        <select id="debug-move-space-select" class="action-select"></select>
                        <button id="debug-move-btn" class="button-group button">Move</button>
                    </div>

                    <!-- Simulate Dice Roll -->
                    <div class="debug-group">
                        <h4>Simulate Dice Roll</h4>
                        <label for="debug-die1">Die 1:</label>
                        <input type="number" id="debug-die1" min="1" max="6" value="1">
                        <label for="debug-die2">Die 2:</label>
                        <input type="number" id="debug-die2" min="1" max="6" value="1">
                        <button id="debug-roll-btn" class="button-group button">Simulate Roll</button>
                    </div>

                    <!-- Change Ownership -->
                    <div class="debug-group">
                        <h4>Change Property Ownership</h4>
                        <select id="debug-property-select" class="action-select"></select>
                        <select id="debug-owner-select" class="action-select"></select>
                        <button id="debug-change-owner-btn" class="button-group button">Change Owner</button>
                    </div>

                    <!-- Manage Houses/Hotels -->
                    <div class="debug-group">
                        <h4>Manage Houses/Hotels</h4>
                        <select id="debug-house-property-select" class="action-select"></select>
                        <label for="debug-house-count">Houses (0-5):</label>
                        <input type="number" id="debug-house-count" min="0" max="5" value="0">
                        <button id="debug-set-houses-btn" class="button-group button">Set Houses</button>
                    </div>

                    <!-- Put Player in Jail -->
                    <div class="debug-group">
                        <h4>Put Player in Jail</h4>
                        <select id="debug-jail-player-select" class="action-select"></select>
                        <button id="debug-send-to-jail-btn" class="button-group button">Send to Jail</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <button id="toggle-debug-btn" style="margin-top: 10px; padding: 8px 15px; background-color: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer;">Toggle Debug Controls</button>

    <!-- Property Info Modal -->
    <div id="property-modal-overlay">
        <div id="property-modal-content">
            <button id="property-modal-close">&times;</button>
            <h3 id="modal-property-name"></h3>
            <div id="modal-property-color-bar" class="color-bar"></div>
            <p><strong>Type:</strong> <span id="modal-property-type"></span></p>
            <p><strong>Price:</strong> $<span id="modal-property-price"></span></p>
            <p><strong>Owner:</strong> <span id="modal-property-owner"></span></p>
            <p><strong>Mortgaged:</strong> <span id="modal-property-mortgaged"></span></p>
            <p id="modal-property-houses-row"><strong>Houses:</strong> <span id="modal-property-houses"></span></p>
            <p id="modal-property-house-cost-row"><strong>House Cost:</strong> $<span id="modal-property-house-cost"></span></p>
            <p><strong>Mortgage Value:</strong> $<span id="modal-property-mortgage-value"></span></p>

            <h4>Rent:</h4>
            <ul id="modal-property-rent-list">
                <!-- Rent details will be inserted here -->
            </ul>
        </div>
    </div>

    <script>
        // --- Game Data ---
        const board = [
            { id: 0, name: "GO", type: "go" },
            { id: 1, name: "Mediterranean Avenue", type: "property", colorGroup: "brown", price: 60, rent: [2, 10, 30, 90, 160, 250], houseCost: 50, owner: null, houses: 0, mortgaged: false },
            { id: 2, name: "Community Chest", type: "community_chest" },
            { id: 3, name: "Baltic Avenue", type: "property", colorGroup: "brown", price: 60, rent: [4, 20, 60, 180, 320, 450], houseCost: 50, owner: null, houses: 0, mortgaged: false },
            { id: 4, name: "Income Tax", type: "tax", amount: 200 },
            { id: 5, name: "Reading Railroad", type: "railroad", price: 200, rent: [25,50,100,200], owner: null, mortgaged: false },
            { id: 6, name: "Oriental Avenue", type: "property", colorGroup: "light-blue", price: 100, rent: [6, 30, 90, 270, 400, 550], houseCost: 50, owner: null, houses: 0, mortgaged: false },
            { id: 7, name: "Chance", type: "chance" },
            { id: 8, name: "Vermont Avenue", type: "property", colorGroup: "light-blue", price: 100, rent: [6, 30, 90, 270, 400, 550], houseCost: 50, owner: null, houses: 0, mortgaged: false },
            { id: 9, name: "Connecticut Avenue", type: "property", colorGroup: "light-blue", price: 120, rent: [8, 40, 100, 300, 450, 600], houseCost: 50, owner: null, houses: 0, mortgaged: false },
            { id: 10, name: "Jail / Just Visiting", type: "jail" },
            { id: 11, name: "St. Charles Place", type: "property", colorGroup: "pink", price: 140, rent: [10, 50, 150, 450, 625, 750], houseCost: 100, owner: null, houses: 0, mortgaged: false },
            { id: 12, name: "Electric Company", type: "utility", price: 150, owner: null, mortgaged: false },
            { id: 13, name: "States Avenue", type: "property", colorGroup: "pink", price: 140, rent: [10, 50, 150, 450, 625, 750], houseCost: 100, owner: null, houses: 0, mortgaged: false },
            { id: 14, name: "Virginia Avenue", type: "property", colorGroup: "pink", price: 160, rent: [12, 60, 180, 500, 700, 800], houseCost: 100, owner: null, houses: 0, mortgaged: false },
            { id: 15, name: "Pennsylvania Railroad", type: "railroad", price: 200, rent: [25,50,100,200], owner: null, mortgaged: false },
            { id: 16, name: "St. James Place", type: "property", colorGroup: "orange", price: 180, rent: [14, 70, 200, 550, 750, 950], houseCost: 100, owner: null, houses: 0, mortgaged: false },
            { id: 17, name: "Community Chest", type: "community_chest" },
            { id: 18, name: "Tennessee Avenue", type: "property", colorGroup: "orange", price: 180, rent: [14, 70, 200, 550, 750, 950], houseCost: 100, owner: null, houses: 0, mortgaged: false },
            { id: 19, name: "New York Avenue", type: "property", colorGroup: "orange", price: 200, rent: [16, 80, 220, 600, 800, 1000], houseCost: 100, owner: null, houses: 0, mortgaged: false },
            { id: 20, name: "Free Parking", type: "freeparking" },
            { id: 21, name: "Kentucky Avenue", type: "property", colorGroup: "red", price: 220, rent: [18, 90, 250, 700, 875, 1050], houseCost: 150, owner: null, houses: 0, mortgaged: false },
            { id: 22, name: "Chance", type: "chance" },
            { id: 23, name: "Indiana Avenue", type: "property", colorGroup: "red", price: 220, rent: [18, 90, 250, 700, 875, 1050], houseCost: 150, owner: null, houses: 0, mortgaged: false },
            { id: 24, name: "Illinois Avenue", type: "property", colorGroup: "red", price: 240, rent: [20, 100, 300, 750, 925, 1100], houseCost: 150, owner: null, houses: 0, mortgaged: false },
            { id: 25, name: "B. & O. Railroad", type: "railroad", price: 200, rent: [25,50,100,200], owner: null, mortgaged: false },
            { id: 26, name: "Atlantic Avenue", type: "property", colorGroup: "yellow", price: 260, rent: [22, 110, 330, 800, 975, 1150], houseCost: 150, owner: null, houses: 0, mortgaged: false },
            { id: 27, name: "Ventnor Avenue", type: "property", colorGroup: "yellow", price: 260, rent: [22, 110, 330, 800, 975, 1150], houseCost: 150, owner: null, houses: 0, mortgaged: false },
            { id: 28, name: "Water Works", type: "utility", price: 150, owner: null, mortgaged: false },
            { id: 29, name: "Marvin Gardens", type: "property", colorGroup: "yellow", price: 280, rent: [24, 120, 360, 850, 1025, 1200], houseCost: 150, owner: null, houses: 0, mortgaged: false },
            { id: 30, name: "Go To Jail", type: "gotojail" },
            { id: 31, name: "Pacific Avenue", type: "property", colorGroup: "green", price: 300, rent: [26, 130, 390, 900, 1100, 1275], houseCost: 200, owner: null, houses: 0, mortgaged: false },
            { id: 32, name: "North Carolina Avenue", type: "property", colorGroup: "green", price: 300, rent: [26, 130, 390, 900, 1100, 1275], houseCost: 200, owner: null, houses: 0, mortgaged: false },
            { id: 33, name: "Community Chest", type: "community_chest" },
            { id: 34, name: "Pennsylvania Avenue", type: "property", colorGroup: "green", price: 320, rent: [28, 150, 450, 1000, 1200, 1400], houseCost: 200, owner: null, houses: 0, mortgaged: false },
            { id: 35, name: "Short Line", type: "railroad", price: 200, rent: [25,50,100,200], owner: null, mortgaged: false },
            { id: 36, name: "Chance", type: "chance" },
            { id: 37, name: "Park Place", type: "property", colorGroup: "dark-blue", price: 350, rent: [35, 175, 500, 1100, 1300, 1500], houseCost: 200, owner: null, houses: 0, mortgaged: false },
            { id: 38, name: "Luxury Tax", type: "tax", amount: 100 },
            { id: 39, name: "Boardwalk", type: "property", colorGroup: "dark-blue", price: 400, rent: [50, 200, 600, 1400, 1700, 2000], houseCost: 200, owner: null, houses: 0, mortgaged: false }
        ];

        let chanceCards = [
            "Advance to Go (Collect $200)",
            "Go to Jail – Go directly to Jail – Do not pass Go, do not collect $200",
            "Bank pays you dividend of $50",
            "Get Out of Jail Free Card",
            "Go back 3 spaces",
            "Pay poor tax of $15",
            "Your building loan matures. Collect $150",
            "You have won a crossword competition. Collect $100"
        ];

        let communityChestCards = [
            "Advance to Go (Collect $200)",
            "Go to Jail – Go directly to Jail – Do not pass Go, do not collect $200",
            "Bank error in your favor – Collect $200",
            "Doctor's fee – Pay $50",
            "Get Out of Jail Free Card",
            "Income Tax refund – Collect $20",
            "Life insurance matures – Collect $100",
            "Pay hospital $100",
            "Pay school fees of $50",
            "Receive $25 consultancy fee",
            "You are assessed for street repairs – Pay $40 per house, $115 per hotel",
            "You have won second prize in a beauty contest – Collect $10",
            "Inherit $100"
        ];

        // --- Game State Variables ---
        let players = [];
        let currentPlayerIndex = 0;
        let diceRoll = [0, 0];
        let doublesCount = 0;
        let gameOver = false;
        let currentActionPending = null; // 'buy', 'manage', 'jail', 'none' (meaning turn over)

        let chanceCardsShuffled = [];
        let communityChestCardsShuffled = [];

        // --- DOM Elements ---
        const setupScreen = document.getElementById('setup-screen');
        const gameScreen = document.getElementById('game-screen');
        const numPlayersInput = document.getElementById('num-players');
        const playerNameInputsDiv = document.getElementById('player-name-inputs');
        const startGameBtn = document.getElementById('start-game-btn');
        const gameBoardDiv = document.getElementById('game-board');
        const currentPlayerDisplay = document.getElementById('current-player-display');
        const diceDisplay = document.getElementById('dice-display');
        const rollDiceBtn = document.getElementById('roll-dice-btn');
        const endTurnBtn = document.getElementById('end-turn-btn');
        const messageLog = document.getElementById('message-log');
        const playerListContainer = document.getElementById('player-list-container');

        // Property action buttons/selects
        const propertyActionsDiv = document.getElementById('property-actions');
        const buyPropertyBtn = document.getElementById('buy-property-btn');
        const buildHouseBtn = document.getElementById('build-house-btn');
        const mortgageSelect = document.getElementById('mortgage-select');
        const mortgagePropertyBtn = document.getElementById('mortgage-property-btn');
        const unmortgageSelect = document.getElementById('unmortgage-select');
        const unmortgagePropertyBtn = document.getElementById('unmortgage-property-btn');
        const sellHouseSelect = document.getElementById('sell-house-select');
        const sellHouseBtn = document.getElementById('sell-house-btn');

        // Jail action buttons
        const jailActionsDiv = document.getElementById('jail-actions');
        const payBailBtn = document.getElementById('pay-bail-btn');
        const useJailCardBtn = document.getElementById('use-jail-card-btn');

        // --- New DOM Elements for Debugging ---
        const debugControlsDiv = document.getElementById('debug-controls');
        const toggleDebugBtn = document.getElementById('toggle-debug-btn');

        // Move Player
        const debugMovePlayerSelect = document.getElementById('debug-move-player-select');
        const debugMoveSpaceSelect = document.getElementById('debug-move-space-select');
        const debugMoveBtn = document.getElementById('debug-move-btn');

        // Simulate Dice Roll
        const debugDie1Input = document.getElementById('debug-die1');
        const debugDie2Input = document.getElementById('debug-die2');
        const debugRollBtn = document.getElementById('debug-roll-btn');

        // Change Ownership
        const debugPropertySelect = document.getElementById('debug-property-select');
        const debugOwnerSelect = document.getElementById('debug-owner-select');
        const debugChangeOwnerBtn = document.getElementById('debug-change-owner-btn');

        // Manage Houses/Hotels
        const debugHousePropertySelect = document.getElementById('debug-house-property-select');
        const debugHouseCountInput = document.getElementById('debug-house-count');
        const debugSetHousesBtn = document.getElementById('debug-set-houses-btn');

        // Put Player in Jail
        const debugJailPlayerSelect = document.getElementById('debug-jail-player-select');
        const debugSendToJailBtn = document.getElementById('debug-send-to-jail-btn');

        // --- Property Info Modal Elements ---
        const propertyModalOverlay = document.getElementById('property-modal-overlay');
        const propertyModalCloseBtn = document.getElementById('property-modal-close');
        const modalPropertyName = document.getElementById('modal-property-name');
        const modalPropertyColorBar = document.getElementById('modal-property-color-bar');
        const modalPropertyType = document.getElementById('modal-property-type');
        const modalPropertyPrice = document.getElementById('modal-property-price');
        const modalPropertyOwner = document.getElementById('modal-property-owner');
        const modalPropertyMortgaged = document.getElementById('modal-property-mortgaged');
        const modalPropertyHousesRow = document.getElementById('modal-property-houses-row');
        const modalPropertyHouses = document.getElementById('modal-property-houses');
        const modalPropertyHouseCostRow = document.getElementById('modal-property-house-cost-row');
        const modalPropertyHouseCost = document.getElementById('modal-property-house-cost');
        const modalPropertyMortgageValue = document.getElementById('modal-property-mortgage-value');
        const modalPropertyRentList = document.getElementById('modal-property-rent-list');


        // --- Utility Functions ---
        function logMessage(message, type = 'info') {
            const div = document.createElement('div');
            div.textContent = message;
            div.className = type;
            messageLog.prepend(div); // Add to top
            if (messageLog.children.length > 50) { // Keep log from getting too long
                messageLog.removeChild(messageLog.lastChild);
            }
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function updatePlayerInfo() {
            playerListContainer.innerHTML = '';
            players.forEach((player, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.className = `player-status ${index === currentPlayerIndex ? 'current' : ''}`;
                playerDiv.innerHTML = `
                    <h4>${player.name} (P${player.id + 1})</h4>
                    <ul>
                        <li>Money: $${player.money}</li>
                        <li>Position: ${board[player.position].name}</li>
                        ${player.inJail ? `<li><span style="color:red;">In Jail (Turn ${player.jailTurns}/3)</span></li>` : ''}
                        ${player.getOutOfJailFreeCards > 0 ? `<li>GOJF Cards: ${player.getOutOfJailFreeCards}</li>` : ''}
                        <li>Properties: ${player.properties.map(pId => board[pId].name + (board[pId].mortgaged ? ' (M)' : '') + (board[pId].houses > 0 ? ` (H:${board[pId].houses})` : '')).join(', ') || 'None'}</li>
                    </ul>
                `;
                playerListContainer.appendChild(playerDiv);
            });
            currentPlayerDisplay.textContent = `Current Player: ${players[currentPlayerIndex].name}`;
        }

        function updateBoardUI() {
            // Remove existing tokens
            document.querySelectorAll('.token').forEach(token => token.remove());

            // Add tokens
            players.forEach(player => {
                const spaceDiv = document.getElementById(`space-${player.position}`);
                if (spaceDiv) {
                    const token = document.createElement('div');
                    token.className = `token p${player.id}`;
                    // Add 'in-jail-position' class if player is in jail and on the jail space
                    if (player.position === 10 && player.inJail) {
                        token.classList.add('in-jail-position'); // For positioning in the corner
                    }
                    spaceDiv.appendChild(token);
                }
            });

            // Update owner and houses on properties
            board.forEach(space => {
                if (['property', 'railroad', 'utility'].includes(space.type)) {
                    const spaceDiv = document.getElementById(`space-${space.id}`);
                    if (spaceDiv) {
                        let ownerSpan = spaceDiv.querySelector('.space-owner');
                        if (!ownerSpan) {
                            ownerSpan = document.createElement('div');
                            ownerSpan.className = 'space-owner';
                            spaceDiv.appendChild(ownerSpan);
                        }
                        if (space.owner !== null) {
                            ownerSpan.textContent = `Owner: ${players[space.owner].name}`;
                            ownerSpan.style.color = space.mortgaged ? 'red' : 'green';
                        } else {
                            ownerSpan.textContent = '';
                        }

                        if (space.type === 'property') {
                            let housesSpan = spaceDiv.querySelector('.space-houses');
                            if (!housesSpan) {
                                housesSpan = document.createElement('div');
                                housesSpan.className = 'space-houses';
                                spaceDiv.appendChild(housesSpan);
                            }
                            housesSpan.textContent = space.houses > 0 ? 'H: ' + space.houses : '';
                        }
                    }
                }
            });
        }

        function getPropertiesByColor(colorGroup) {
            return board.filter(space => space.type === 'property' && space.colorGroup === colorGroup);
        }

        function getRailroads() {
            return board.filter(space => space.type === 'railroad');
        }

        function getUtilities() {
            return board.filter(space => space.type === 'utility');
        }

        function checkMonopoly(player, colorGroup) {
            const propertiesInGroup = getPropertiesByColor(colorGroup);
            return propertiesInGroup.every(prop => prop.owner === player.id);
        }

        function getPlayerOwnedProperties(player, type = null) {
            return board.filter(space => space.owner === player.id && (type ? space.type === type : true));
        }

        // --- Game Logic ---

        function startGame() {
            const numPlayers = parseInt(numPlayersInput.value);
            players = [];
            for (let i = 0; i < numPlayers; i++) {
                const nameInput = document.getElementById(`player-name-${i}`);
                players.push({
                    id: i,
                    name: nameInput.value || `Player ${i + 1}`,
                    money: 1500,
                    position: 0,
                    properties: [],
                    inJail: false,
                    jailTurns: 0,
                    getOutOfJailFreeCards: 0,
                    doublesRolledThisTurn: 0,
                    hasRolled: false // To enforce only one roll per turn unless doubles
                });
            }

            // Shuffle chance and community chest cards (shallow copy to keep originals)
            chanceCardsShuffled = shuffleArray([...chanceCards]);
            communityChestCardsShuffled = shuffleArray([...communityChestCards]);

            setupScreen.style.display = 'none';
            gameScreen.style.display = 'block';

            createBoardUI();
            updatePlayerInfo();
            updateBoardUI();
            logMessage("Game Started!", "success");
            logMessage(`It's ${players[currentPlayerIndex].name}'s turn.`);
            setControlsForTurnStart();
            refreshDebugControls(); // Populate debug dropdowns after players are initialized
        }

        function createBoardUI() {
            gameBoardDiv.innerHTML = ''; // Clear existing board
            // The CSS grid-area properties are manually defined and assume the `board` array order.
            // This loop just creates the divs for each board space
            board.forEach((space, index) => {
                const spaceDiv = document.createElement('div');
                spaceDiv.id = `space-${space.id}`;
                spaceDiv.classList.add('board-space');
                spaceDiv.dataset.spaceId = space.id; // Add data-id for click handling
                if ([0, 10, 20, 30].includes(space.id)) {
                    spaceDiv.classList.add('corner');
                }
                // Assign grid positions based on typical Monopoly board layout
                // (This CSS is hardcoded for specific IDs and their board positions for visual layout)
                if (space.id >= 0 && space.id <= 10) { // Bottom row (Go to Jail)
                    spaceDiv.style.gridArea = `11 / ${11 - space.id}`;
                } else if (space.id >= 11 && space.id <= 19) { // Left column (Jail to NY Ave)
                    spaceDiv.style.gridArea = `${11 - (space.id - 10)} / 1`;
                } else if (space.id >= 20 && space.id <= 30) { // Top row (Free Parking to Go To Jail)
                    spaceDiv.style.gridArea = `1 / ${space.id - 19}`;
                } else if (space.id >= 31 && space.id <= 39) { // Right column (Go To Jail to Boardwalk)
                    spaceDiv.style.gridArea = `${(space.id - 29)} / 11`;
                }

                if (space.type === 'property' || space.type === 'railroad' || space.type === 'utility') {
                    const colorBar = document.createElement('div');
                    colorBar.className = `property-color-bar ${space.colorGroup || ''}`;
                    spaceDiv.appendChild(colorBar);
                }

                const nameDiv = document.createElement('div');
                nameDiv.className = 'space-name';
                nameDiv.textContent = space.name;
                spaceDiv.appendChild(nameDiv);

                if (space.price) {
                    const priceDiv = document.createElement('div');
                    priceDiv.className = 'space-price';
                    priceDiv.textContent = `$${space.price}`;
                    spaceDiv.appendChild(priceDiv);
                }
                gameBoardDiv.appendChild(spaceDiv);
            });
        }


        function rollDice(simulatedDie1 = null, simulatedDie2 = null) {
            const die1 = simulatedDie1 !== null ? simulatedDie1 : Math.floor(Math.random() * 6) + 1;
            const die2 = simulatedDie2 !== null ? simulatedDie2 : Math.floor(Math.random() * 6) + 1;
            
            diceRoll = [die1, die2];
            diceDisplay.textContent = `Dice: ${die1}, ${die2}`;
            logMessage(`${players[currentPlayerIndex].name} rolled a ${die1} and a ${die2} (total ${die1 + die2}).`);

            const player = players[currentPlayerIndex];
            player.hasRolled = true; // Mark that player has rolled this turn

            // Check for doubles
            if (die1 === die2) {
                player.doublesRolledThisTurn++;
                logMessage(`${player.name} rolled doubles!`, 'warning');
                if (player.doublesRolledThisTurn === 3) {
                    logMessage(`${player.name} rolled 3 consecutive doubles! Go directly to Jail!`, 'error');
                    sendToJail(player);
                    player.doublesRolledThisTurn = 0; // Reset doubles count
                    currentActionPending = 'none'; // Turn ends
                    setControls(); // Ensure controls are updated for turn end
                    return;
                }
            } else {
                player.doublesRolledThisTurn = 0; // Reset doubles if not doubles
            }

            if (player.inJail) {
                handleJailRoll(player, die1, die2);
            } else {
                movePlayer(player, die1 + die2);
            }
        }

        function movePlayer(player, steps) {
            const oldPosition = player.position;
            player.position = (player.position + steps) % board.length;
            logMessage(`${player.name} moved from ${board[oldPosition].name} to ${board[player.position].name}.`);

            // Check for passing Go
            if (player.position < oldPosition && !player.inJail) { // If went past index 0
                player.money += 200;
                logMessage(`${player.name} passed GO and collected $200!`);
            }
            updatePlayerInfo();
            updateBoardUI();
            landOnSpace(player);
        }

        function sendToJail(player) {
            player.position = 10; // Jail space
            player.inJail = true;
            player.jailTurns = 0; // Reset jail turns for new entry
            logMessage(`${player.name} is now in Jail!`);
            updatePlayerInfo();
            updateBoardUI();
            // No landOnSpace for jail, just go to it.
            // The turn should end immediately after being sent to jail.
            currentActionPending = 'none'; // Ensure turn ends
            setControls(); // Update controls to reflect turn end
        }

        function handleJailRoll(player, die1, die2) {
            if (die1 === die2) {
                logMessage(`${player.name} rolled doubles (${die1}, ${die2}) and got out of Jail!`, 'success');
                player.inJail = false;
                player.jailTurns = 0;
                movePlayer(player, die1 + die2); // Move out of jail
            } else {
                player.jailTurns++;
                logMessage(`${player.name} rolled ${die1}, ${die2}. Still in jail. Turns left: ${3 - player.jailTurns}.`);

                // If player is still in jail after 3rd roll attempt, their turn ends.
                // The forcing of bail/card will be handled by setControlsForJailStartTurn on the *next* turn.
                // However, if they are bankrupt immediately, handle that.
                if (player.jailTurns === 3 && player.money < 50 && player.getOutOfJailFreeCards === 0) {
                    logMessage(`${player.name} cannot pay bail or use a card and is bankrupt!`, 'error');
                    handleBankruptcy(player, 'bank', 50); // Debt is 50 for bail
                }
                currentActionPending = 'none'; // Turn ends after rolling in jail (unless doubles)
                setControls(); // Update controls based on currentActionPending
            }
        }


        function landOnSpace(player) {
            const space = board[player.position];
            logMessage(`${player.name} landed on ${space.name}.`);

            currentActionPending = 'none'; // Default to turn ending, will be overridden if action is needed

            switch (space.type) {
                case 'property':
                case 'railroad':
                case 'utility':
                    if (space.owner === null) {
                        // Property is unowned
                        logMessage(`${space.name} is unowned. Price: $${space.price}.`);
                        if (player.money >= space.price) {
                            currentActionPending = 'buy';
                        } else {
                            logMessage(`${player.name} cannot afford ${space.name}.`, 'warning');
                            currentActionPending = 'none'; // Turn ends if unaffordable
                        }
                    } else if (space.owner !== player.id) {
                        // Property is owned by another player
                        const owner = players[space.owner];
                        if (space.mortgaged) {
                            logMessage(`${space.name} is mortgaged by ${owner.name}. No rent.`, 'info');
                        } else {
                            let rent = 0;
                            if (space.type === 'property') {
                                rent = space.rent[space.houses];
                                if (space.houses === 0 && checkMonopoly(owner, space.colorGroup)) {
                                    rent *= 2; // Double rent if monopoly owned and no houses
                                    logMessage(`Rent is doubled as ${owner.name} owns the full ${space.colorGroup} monopoly.`);
                                }
                            } else if (space.type === 'railroad') {
                                const ownedRailroads = getPlayerOwnedProperties(owner, 'railroad').filter(r => !r.mortgaged).length;
                                rent = space.rent[ownedRailroads - 1]; // Use predefined rent array for railroads
                            } else if (space.type === 'utility') {
                                const ownedUtilities = getPlayerOwnedProperties(owner, 'utility').filter(u => !u.mortgaged).length;
                                if (ownedUtilities === 1) {
                                    rent = (diceRoll[0] + diceRoll[1]) * 4;
                                } else if (ownedUtilities === 2) {
                                    rent = (diceRoll[0] + diceRoll[1]) * 10;
                                }
                            }
                            logMessage(`${space.name} is owned by ${owner.name}. Rent: $${rent}.`);
                            payMoney(player, owner, rent);
                        }
                        currentActionPending = 'none'; // After paying rent, turn ends
                    } else {
                        // Property is owned by current player
                        logMessage(`${player.name} owns ${space.name}.`);
                        currentActionPending = 'manage'; // Player can choose to build/mortgage
                    }
                    break;
                case 'tax':
                    logMessage(`${player.name} landed on ${space.name} and must pay $${space.amount}.`);
                    payMoney(player, 'bank', space.amount);
                    currentActionPending = 'none';
                    break;
                case 'chance':
                    drawCard(player, chanceCardsShuffled);
                    // currentActionPending will be set by drawCard based on if player moved or not
                    break;
                case 'community_chest':
                    drawCard(player, communityChestCardsShuffled);
                    // currentActionPending will be set by drawCard based on if player moved or not
                    break;
                case 'gotojail':
                    sendToJail(player);
                    // sendToJail already sets currentActionPending = 'none' and calls setControls
                    break;
                case 'jail': // Just Visiting
                    logMessage(`${player.name} is just visiting Jail.`, 'info');
                    currentActionPending = 'none'; // No action for just visiting, turn ends
                    break;
                case 'go':
                case 'freeparking':
                    logMessage(`${player.name} is on ${space.name}. Nothing to do.`, 'info');
                    currentActionPending = 'none'; // No action, turn ends
                    break;
            }
            setControls(); // Update controls based on currentActionPending
        }

        function buyProperty(player, space) {
            if (player.money >= space.price && space.owner === null) {
                player.money -= space.price;
                space.owner = player.id;
                player.properties.push(space.id);
                logMessage(`${player.name} bought ${space.name} for $${space.price}.`, 'success');
                updatePlayerInfo();
                updateBoardUI();
            } else {
                logMessage(`Could not buy ${space.name}. Either not enough money or already owned.`, 'error');
            }
            // After buying (or attempting to buy), turn ends
            currentActionPending = 'none';
            setControls();
        }

        function payMoney(fromPlayer, toRecipient, amount) {
            if (fromPlayer.money >= amount) {
                fromPlayer.money -= amount;
                if (toRecipient !== 'bank') {
                    toRecipient.money += amount;
                    logMessage(`${fromPlayer.name} paid $${amount} to ${toRecipient.name}.`);
                } else {
                    logMessage(`${fromPlayer.name} paid $${amount} to the Bank.`);
                }
            } else {
                // Player cannot afford, handle bankruptcy
                logMessage(`${fromPlayer.name} cannot pay $${amount}! Declaring bankruptcy...`, 'error');
                handleBankruptcy(fromPlayer, toRecipient, amount);
            }
            updatePlayerInfo();
        }

        function handleBankruptcy(bankruptPlayer, recipient, debtAmount) {
            logMessage(`${bankruptPlayer.name} has gone bankrupt!`);
            // Sell all properties to pay debt
            bankruptPlayer.properties.sort((a,b) => board[a].price - board[b].price); // Try to sell cheapest first

            while (bankruptPlayer.money < debtAmount && bankruptPlayer.properties.length > 0) {
                const propId = bankruptPlayer.properties[0]; // Cheapest property
                const prop = board[propId];

                // Sell houses first if any
                while(prop.houses > 0) {
                    prop.houses--;
                    bankruptPlayer.money += prop.houseCost / 2;
                    logMessage(`${bankruptPlayer.name} sold a house on ${prop.name} for $${prop.houseCost / 2}.`);
                    updatePlayerInfo();
                    updateBoardUI();
                }

                // Mortgage property if still in debt
                if (!prop.mortgaged) {
                    prop.mortgaged = true;
                    bankruptPlayer.money += prop.price / 2;
                    logMessage(`${bankruptPlayer.name} mortgaged ${prop.name} for $${prop.price / 2}.`);
                    updatePlayerInfo();
                    updateBoardUI();
                } else {
                    // If mortgaged and still can't pay, can't sell more from this property
                    break;
                }
            }

            if (bankruptPlayer.money < debtAmount) {
                logMessage(`${bankruptPlayer.name} cannot cover the debt and is out of the game!`, 'error');
                // Transfer properties to the recipient if it's another player
                if (recipient !== 'bank' && recipient.id !== bankruptPlayer.id) {
                    bankruptPlayer.properties.forEach(propId => {
                        const prop = board[propId];
                        prop.owner = recipient.id;
                        recipient.properties.push(propId);
                        prop.mortgaged = true; // Properties are transferred mortgaged
                        prop.houses = 0; // Houses are removed upon transfer
                        logMessage(`${prop.name} transferred to ${recipient.name} (mortgaged).`);
                    });
                } else {
                    // If bankrupt to bank or self, properties return to unowned state
                    bankruptPlayer.properties.forEach(propId => {
                        const prop = board[propId];
                        prop.owner = null;
                        prop.houses = 0;
                        prop.mortgaged = false; // Reset for next owner
                        logMessage(`${prop.name} returned to the bank.`);
                    });
                }
                // Remove player from game
                players = players.filter(p => p.id !== bankruptPlayer.id);
                // Adjust currentPlayerIndex if current player was removed
                if (currentPlayerIndex >= players.length) {
                    currentPlayerIndex = 0;
                }
                updatePlayerInfo();
                updateBoardUI();
                checkWinCondition();
            } else {
                logMessage(`${bankruptPlayer.name} managed to pay the debt after selling assets.`);
                payMoney(bankruptPlayer, recipient, debtAmount); // Re-attempt payment after assets sold
            }
        }


        function checkWinCondition() {
            if (players.length === 1) {
                gameOver = true;
                logMessage(`${players[0].name} is the last player standing! ${players[0].name} wins!`, 'success');
                rollDiceBtn.disabled = true;
                endTurnBtn.disabled = true;
                propertyActionsDiv.style.display = 'none';
                jailActionsDiv.style.display = 'none';
            }
        }

        function drawCard(player, deck) {
            const card = deck.shift(); // Take top card
            deck.push(card); // Put card at bottom of deck

            logMessage(`${player.name} drew a ${card.includes('Community Chest') ? 'Community Chest' : 'Chance'} card: "${card}"`);

            let movedByCard = false; // Flag to indicate if the player was moved by this card

            switch (card) {
                case "Advance to Go (Collect $200)":
                    player.money += 200;
                    player.position = 0;
                    logMessage(`${player.name} advanced to Go and collected $200.`);
                    movedByCard = true; // Player moved
                    break;
                case "Go to Jail – Go directly to Jail – Do not pass Go, do not collect $200":
                    sendToJail(player);
                    // sendToJail already handles setting controls and logging, no need for landOnSpace here
                    break;
                case "Bank pays you dividend of $50": // Chance
                case "Bank error in your favor – Collect $200": // Community Chest
                case "Income Tax refund – Collect $20": // Community Chest
                case "Life insurance matures – Collect $100": // Community Chest
                case "Receive $25 consultancy fee": // Community Chest
                case "You have won second prize in a beauty contest – Collect $10": // Community Chest
                case "Inherit $100": // Community Chest
                case "Your building loan matures. Collect $150": // Chance
                case "You have won a crossword competition. Collect $100": // Chance
                    const amount = parseInt(card.match(/\$([\d]+)/)[1]);
                    player.money += amount;
                    logMessage(`${player.name} collected $${amount}.`);
                    break;
                case "Doctor's fee – Pay $50": // Community Chest
                case "Pay hospital $100": // Community Chest
                case "Pay school fees of $50": // Community Chest
                case "Pay poor tax of $15": // Chance
                    const payAmount = parseInt(card.match(/\$([\d]+)/)[1]);
                    payMoney(player, 'bank', payAmount);
                    break;
                case "Get Out of Jail Free Card":
                    player.getOutOfJailFreeCards++;
                    logMessage(`${player.name} received a Get Out of Jail Free card.`);
                    break;
                case "Go back 3 spaces":
                    player.position = (player.position - 3 + board.length) % board.length;
                    logMessage(`${player.name} moved back 3 spaces to ${board[player.position].name}.`);
                    movedByCard = true; // Player moved
                    break;
                case "You are assessed for street repairs – Pay $40 per house, $115 per hotel": // Community Chest
                    let repairCost = 0;
                    player.properties.forEach(propId => {
                        const prop = board[propId];
                        if (prop.type === 'property') {
                            if (prop.houses < 5) {
                                repairCost += prop.houses * 40;
                            } else if (prop.houses === 5) { // Hotel
                                repairCost += 115;
                            }
                        }
                    });
                    if (repairCost > 0) {
                        logMessage(`${player.name} must pay $${repairCost} for street repairs.`);
                        payMoney(player, 'bank', repairCost);
                    } else {
                        logMessage(`${player.name} has no buildings, no repair cost.`);
                    }
                    break;
                default:
                    logMessage(`Unhandled card: "${card}".`, 'warning');
            }
            updatePlayerInfo();
            updateBoardUI();

            // IMPORTANT FIX: If the player was moved by the card, land on the new space
            if (movedByCard) {
                landOnSpace(player);
            } else {
                // If no movement, the turn typically ends after a card action
                currentActionPending = 'none';
                setControls();
            }
        }

        // --- Property Management Actions ---

        function showBuyPropertyAction(player, space) {
            propertyActionsDiv.style.display = 'flex';
            buyPropertyBtn.style.display = 'inline-block';
            buyPropertyBtn.onclick = () => buyProperty(player, space);

            // Hide other management options
            buildHouseBtn.style.display = 'none';
            mortgageSelect.style.display = 'none';
            mortgagePropertyBtn.style.display = 'none';
            unmortgageSelect.style.display = 'none';
            unmortgagePropertyBtn.style.display = 'none';
            sellHouseSelect.style.display = 'none';
            sellHouseBtn.style.display = 'none';
        }

        function showPropertyManagementActions(player) {
            // Hide "Buy Property" button
            buyPropertyBtn.style.display = 'none';

            // Build House
            let buildableProperties = getPlayerOwnedProperties(player, 'property').filter(prop =>
                !prop.mortgaged && prop.houses < 5 && checkMonopoly(player, prop.colorGroup) &&
                player.money >= prop.houseCost
            ).sort((a,b) => a.houses - b.houses); // Sort by fewest houses for even building enforcement

            const availableToBuild = [];
            // First, find properties that are at the minimum house count within their monopoly group
            if (buildableProperties.length > 0) {
                const minHousesInAnyGroup = Math.min(...buildableProperties.map(p => p.houses));
                for (const prop of buildableProperties) {
                    if (prop.houses === minHousesInAnyGroup) {
                        availableToBuild.push(prop);
                    }
                }
            }

            buildHouseBtn.style.display = availableToBuild.length > 0 ? 'inline-block' : 'none';
            if (availableToBuild.length > 0) {
                buildHouseBtn.onclick = () => showBuildHouseDialog(player, availableToBuild);
            }


            // Mortgage
            let mortgagableProperties = getPlayerOwnedProperties(player, 'property').filter(prop =>
                !prop.mortgaged && prop.houses === 0 // Can only mortgage if no houses
            ).concat(getPlayerOwnedProperties(player, 'railroad').filter(prop => !prop.mortgaged))
            .concat(getPlayerOwnedProperties(player, 'utility').filter(prop => !prop.mortgaged));

            populateSelect(mortgageSelect, mortgagableProperties, 'Mortgage');
            mortgageSelect.style.display = mortgagableProperties.length > 0 ? 'block' : 'none';
            mortgagePropertyBtn.style.display = mortgagableProperties.length > 0 ? 'inline-block' : 'none';


            // Unmortgage
            let unmortgagableProperties = getPlayerOwnedProperties(player).filter(prop => prop.mortgaged && player.money >= Math.ceil(prop.price / 2 * 1.1));
            populateSelect(unmortgageSelect, unmortgagableProperties, 'Unmortgage');
            unmortgageSelect.style.display = unmortgagableProperties.length > 0 ? 'block' : 'none';
            unmortgagePropertyBtn.style.display = unmortgagableProperties.length > 0 ? 'inline-block' : 'none';

            // Sell Houses (Must be able to sell evenly from a group, for simplicity, list all properties with houses)
            let sellableHouseProperties = getPlayerOwnedProperties(player, 'property').filter(prop => prop.houses > 0);
            populateSelect(sellHouseSelect, sellableHouseProperties, 'Sell Houses');
            sellHouseSelect.style.display = sellableHouseProperties.length > 0 ? 'block' : 'none';
            sellHouseBtn.style.display = sellableHouseProperties.length > 0 ? 'inline-block' : 'none';


            // Show the whole property actions div if any button/select is visible
            propertyActionsDiv.style.display = (
                buildHouseBtn.style.display !== 'none' ||
                mortgageSelect.style.display !== 'none' ||
                unmortgageSelect.style.display !== 'none' ||
                sellHouseSelect.style.display !== 'none'
            ) ? 'flex' : 'none';
        }

        function populateSelect(selectElement, properties, defaultOptionText) {
            selectElement.innerHTML = `<option value="">-- ${defaultOptionText} --</option>`;
            properties.forEach(prop => {
                const option = document.createElement('option');
                option.value = prop.id;
                option.textContent = `${prop.name} ${prop.mortgaged ? '(Mortgaged)' : ''} ${prop.houses > 0 ? `(H: ${prop.houses})` : ''} - Cost: $${prop.type === 'property' && prop.houses < 5 ? (prop.houses < 4 ? prop.houseCost : (prop.houses === 4 ? prop.houseCost : '')) : (prop.type === 'railroad' || prop.type === 'utility' ? prop.price/2 : '')}`;
                selectElement.appendChild(option);
            });
            selectElement.onchange = () => {
                if (selectElement === mortgageSelect) mortgagePropertyBtn.disabled = !selectElement.value;
                if (selectElement === unmortgageSelect) unmortgagePropertyBtn.disabled = !selectElement.value;
                if (selectElement === sellHouseSelect) sellHouseBtn.disabled = !selectElement.value;
            };
            if (properties.length > 0) {
                selectElement.value = ''; // Reset to default option
            } else {
                selectElement.value = '';
            }
            selectElement.disabled = properties.length === 0;
            if (selectElement === mortgageSelect) mortgagePropertyBtn.disabled = true;
            if (selectElement === unmortgageSelect) unmortgagePropertyBtn.disabled = true;
            if (selectElement === sellHouseSelect) sellHouseBtn.disabled = true;
        }

        function showBuildHouseDialog(player, availableProperties) {
            const selectDiv = document.createElement('div');
            selectDiv.className = 'build-house-dialog';
            selectDiv.innerHTML = `
                <p>Build on:</p>
                <select id="build-house-prop-select" class="action-select"></select>
                <button id="confirm-build-btn">Build</button>
                <button id="cancel-build-btn">Cancel</button>
            `;
            const buildSelect = selectDiv.querySelector('#build-house-prop-select');
            const confirmBtn = selectDiv.querySelector('#confirm-build-btn');
            const cancelBtn = selectDiv.querySelector('#cancel-build-btn');

            buildSelect.innerHTML = `<option value="">-- Select Property to Build On --</option>`;
            availableProperties.forEach(prop => {
                const option = document.createElement('option');
                option.value = prop.id;
                option.textContent = `${prop.name} (H: ${prop.houses}) - Cost: $${prop.houseCost}`;
                buildSelect.appendChild(option);
            });
            confirmBtn.disabled = true; // Initially disabled

            buildSelect.onchange = () => {
                confirmBtn.disabled = !buildSelect.value;
            };

            propertyActionsDiv.appendChild(selectDiv);
            buildHouseBtn.style.display = 'none'; // Hide main build button while dialog is open

            confirmBtn.onclick = () => {
                const propId = parseInt(buildSelect.value);
                const prop = board[propId];
                if (prop && prop.owner === player.id && player.money >= prop.houseCost && prop.houses < 5) {
                    const group = getPropertiesByColor(prop.colorGroup);
                    const maxHousesInGroup = Math.max(...group.filter(p => p.owner === player.id).map(p => p.houses));
                    // Enforce building evenly within a group: can only build if this property has the minimum houses in the group
                    const minHousesInGroup = Math.min(...group.filter(p => p.owner === player.id).map(p => p.houses));
                    if (prop.houses > minHousesInGroup) {
                        logMessage("Must build houses evenly across the monopoly group. Build on properties with fewer houses first.", "error");
                        return;
                    }

                    player.money -= prop.houseCost;
                    prop.houses++;
                    logMessage(`${player.name} built a house on ${prop.name}. Houses: ${prop.houses}.`);
                    updatePlayerInfo();
                    updateBoardUI();
                    propertyActionsDiv.removeChild(selectDiv);
                    showPropertyManagementActions(player); // Re-evaluate and show/hide options
                    setControls(); // Re-evaluate main controls
                } else {
                    logMessage("Cannot build house here.", "error");
                }
            };
            cancelBtn.onclick = () => {
                propertyActionsDiv.removeChild(selectDiv);
                showPropertyManagementActions(player); // Re-evaluate and show/hide options
                setControls(); // Re-evaluate main controls
            };
        }


        function mortgageProperty(player, propId) {
            const prop = board[propId];
            if (prop && prop.owner === player.id && !prop.mortgaged && prop.houses === 0) {
                prop.mortgaged = true;
                player.money += prop.price / 2;
                logMessage(`${player.name} mortgaged ${prop.name} for $${prop.price / 2}.`, 'info');
                updatePlayerInfo();
                updateBoardUI();
                showPropertyManagementActions(player); // Refresh actions
            } else {
                logMessage(`Cannot mortgage ${prop.name}. Must have no houses and own it.`, 'error');
            }
        }

        function unmortgageProperty(player, propId) {
            const prop = board[propId];
            const unmortgageCost = Math.ceil(prop.price / 2 * 1.1); // Cost + 10% interest
            if (prop && prop.owner === player.id && prop.mortgaged && player.money >= unmortgageCost) {
                prop.mortgaged = false;
                player.money -= unmortgageCost;
                logMessage(`${player.name} unmortgaged ${prop.name} for $${unmortgageCost}.`, 'info');
                updatePlayerInfo();
                updateBoardUI();
                showPropertyManagementActions(player); // Refresh actions
            } else {
                logMessage(`Cannot unmortgage ${prop.name}. Not enough money or not mortgaged.`, 'error');
            }
        }

        function sellHouse(player, propId) {
            const prop = board[propId];
            if (prop && prop.owner === player.id && prop.houses > 0) {
                const group = getPropertiesByColor(prop.colorGroup);
                const minHousesInGroup = Math.min(...group.filter(p => p.owner === player.id).map(p => p.houses));
                if (prop.houses > minHousesInGroup) {
                    logMessage("Must sell houses evenly across the monopoly group. Sell from properties with more houses first.", "error");
                    return;
                }
                
                prop.houses--;
                player.money += prop.houseCost / 2;
                logMessage(`${player.name} sold a house on ${prop.name} for $${prop.houseCost / 2}. Houses: ${prop.houses}.`, 'info');
                updatePlayerInfo();
                updateBoardUI();
                showPropertyManagementActions(player); // Refresh actions
            } else {
                logMessage(`Cannot sell house on ${prop.name}. No houses to sell or not owned.`, 'error');
            }
        }


        // --- Control Management ---
        function setControls() {
            const player = players[currentPlayerIndex];

            // --- DEBUG LOGS ---
            console.log("--- setControls called ---");
            console.log(`Player: ${player.name} (ID: ${player.id})`);
            console.log(`inJail: ${player.inJail}, hasRolled: ${player.hasRolled}, doublesRolledThisTurn: ${player.doublesRolledThisTurn}, jailTurns: ${player.jailTurns}`);
            console.log(`currentActionPending: ${currentActionPending}`);
            // --- END DEBUG LOGS ---

            // Hide all action divs first
            propertyActionsDiv.style.display = 'none';
            jailActionsDiv.style.display = 'none';
            buyPropertyBtn.style.display = 'none';
            buildHouseBtn.style.display = 'none';
            showPropertyManagementActions(player); // This will manage its own internal elements

            if (gameOver) {
                console.log("setControls: Game Over.");
                rollDiceBtn.disabled = true;
                endTurnBtn.disabled = true;
                return;
            }

            // Scenario 1: Player just landed on "Go To Jail" (or drew a "Go To Jail" card)
            // OR Player just rolled in jail and did NOT get out (turn ends)
            if (player.inJail && player.hasRolled) {
                console.log("setControls: Player in jail and has rolled (turn ends).");
                rollDiceBtn.disabled = true; // Cannot roll again
                endTurnBtn.disabled = false; // Can end turn
                jailActionsDiv.style.display = 'none'; // No jail actions this turn, just went there or failed roll
                currentActionPending = 'none'; // Ensure turn ends
            }
            // Scenario 2: Player is starting their turn in Jail (hasRolled is false)
            else if (player.inJail) {
                console.log("setControls: Player in jail (start of turn).");
                jailActionsDiv.style.display = 'flex';
                payBailBtn.disabled = (player.money < 50);
                useJailCardBtn.disabled = (player.getOutOfJailFreeCards === 0);

                if (player.jailTurns === 3) { // On 3rd turn, must pay/use card
                    console.log("setControls: Player on 3rd jail turn, must pay/use card.");
                    logMessage(`${player.name} is on their 3rd turn in Jail. Must pay $50 bail or use a Get Out of Jail Free card.`, 'warning');
                    rollDiceBtn.disabled = true; // Cannot roll
                    endTurnBtn.disabled = true; // Cannot end turn until bail is paid/card used
                    propertyActionsDiv.style.display = 'none'; // No property actions while forced to pay bail

                    if (payBailBtn.disabled && useJailCardBtn.disabled) {
                        console.log("setControls: Player bankrupt from jail.");
                        logMessage(`${player.name} cannot pay bail or use a card and is bankrupt!`, 'error');
                        handleBankruptcy(player, 'bank', 50);
                        currentActionPending = 'none';
                        setControls(); // Re-call to update after bankruptcy
                        return;
                    }
                } else { // Not 3rd turn, can roll to try to get out
                    console.log("setControls: Player in jail, can roll to get out.");
                    rollDiceBtn.disabled = false; // Can roll
                    endTurnBtn.disabled = true; // Cannot end turn until resolved jail
                }
            }
            // Original logic for non-jail scenarios (order matters here)
            else if (player.doublesRolledThisTurn > 0 && player.doublesRolledThisTurn < 3) {
                console.log("setControls: Player rolled doubles, can roll again.");
                // Rolled doubles, can roll again. Actions for current space *before* re-roll.
                rollDiceBtn.disabled = false; // Can roll again
                endTurnBtn.disabled = true; // Must roll again or perform actions
                if (currentActionPending === 'buy') {
                    const space = board[player.position];
                    showBuyPropertyAction(player, space);
                } else if (currentActionPending === 'manage') {
                    showPropertyManagementActions(player);
                }
            } else if (currentActionPending === 'buy') {
                console.log("setControls: Player can buy property.");
                rollDiceBtn.disabled = true; // Cannot roll again
                endTurnBtn.disabled = false; // Can choose to end turn without buying
                const space = board[player.position];
                showBuyPropertyAction(player, space);
            } else if (currentActionPending === 'manage') {
                console.log("setControls: Player can manage property.");
                rollDiceBtn.disabled = true; // Cannot roll again
                endTurnBtn.disabled = false; // Can end turn
                showPropertyManagementActions(player);
            } else { // Turn is over or no specific action required on space (currentActionPending === 'none')
                console.log("setControls: Turn over, no special actions pending.");
                // This is the default state after a non-doubles roll, or after an action is completed.
                rollDiceBtn.disabled = true; // Player has rolled and no further action needed
                endTurnBtn.disabled = false; // Can end turn
            }
            console.log(`setControls: Final button states: Roll Dice Disabled: ${rollDiceBtn.disabled}, End Turn Disabled: ${endTurnBtn.disabled}`);
        }

        function setControlsForTurnStart() {
            const player = players[currentPlayerIndex];
            player.hasRolled = false; // Reset for new turn
            player.doublesRolledThisTurn = 0; // Reset for new turn
            currentActionPending = 'none'; // Clear any pending actions

            rollDiceBtn.disabled = false;
            endTurnBtn.disabled = true;
            propertyActionsDiv.style.display = 'none';
            jailActionsDiv.style.display = 'none';
            buyPropertyBtn.style.display = 'none';
            showPropertyManagementActions(player); // This will hide/show management options based on player's properties
                                                // but it won't affect the buy button display.

            if (player.inJail) {
                logMessage(`${player.name} is in Jail.`, 'warning');
                setControlsForJailStartTurn(); // Specific jail controls at start of turn
            }
        }

        function setControlsForJailStartTurn() {
            const player = players[currentPlayerIndex];
            jailActionsDiv.style.display = 'flex';
            payBailBtn.disabled = (player.money < 50);
            useJailCardBtn.disabled = (player.getOutOfJailFreeCards === 0);

            if (player.jailTurns === 3) {
                logMessage(`${player.name} is on their 3rd turn in Jail. Must pay $50 bail or use a Get Out of Jail Free card.`, 'warning');
                rollDiceBtn.disabled = true; // Cannot roll
                endTurnBtn.disabled = true; // Cannot end turn until bail is paid/card used
                // Hide property actions if they are forced to pay bail
                propertyActionsDiv.style.display = 'none';

                // If they can't pay or use card, they are bankrupt.
                if (payBailBtn.disabled && useJailCardBtn.disabled) {
                    logMessage(`${player.name} cannot pay bail or use a card and is bankrupt!`, 'error');
                    handleBankruptcy(player, 'bank', 50); // Debt is 50 for bail
                    currentActionPending = 'none'; // Turn ends after bankruptcy
                    setControls(); // Re-call setControls to update after bankruptcy
                    return; // Exit to prevent further control setting
                }
            } else { // Not 3rd turn, can roll
                rollDiceBtn.disabled = false;
                endTurnBtn.disabled = true; // Can't end turn until resolved jail
            }
        }


        function endTurn() {
            if (gameOver) return;

            logMessage(`${players[currentPlayerIndex].name}'s turn ended.`);
            // doublesRolledThisTurn and hasRolled are reset in setControlsForTurnStart

            // Move to next player that is still in the game
            let nextPlayerFound = false;
            let originalIndex = currentPlayerIndex; // Store original index in case all other players bankrupt
            let loopCount = 0; // Prevent infinite loop if no players left (should be caught by gameOver)

            do {
                currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
                loopCount++;
                if (loopCount > players.length * 2) { // Safety break, should not happen with proper bankruptcy handling
                    logMessage("Error: Could not find next player.", "error");
                    gameOver = true;
                    return;
                }
                // Check if the player at the new index is still in the active players array
                // This check is implicitly handled by `players.length` in the loop condition
                // and `players` array being filtered on bankruptcy.
                // The `players` array itself will only contain active players.
                nextPlayerFound = true; // If we reached here, a next player exists in the filtered array
            } while (!nextPlayerFound); // This loop will only run once if players.length > 0

            // If only one player left, game should have ended via checkWinCondition
            if (players.length <= 1) {
                checkWinCondition();
                return;
            }

            logMessage(`It's ${players[currentPlayerIndex].name}'s turn.`);
            setControlsForTurnStart();
            updatePlayerInfo();
        }


        // --- Property Info Modal Logic ---
        function showPropertyModal(spaceId) {
            const space = board[spaceId];
            if (!space || !['property', 'railroad', 'utility'].includes(space.type)) {
                // Only show modal for properties, railroads, and utilities
                return;
            }

            modalPropertyName.textContent = space.name;
            modalPropertyType.textContent = space.type.replace('_', ' ').toUpperCase();
            modalPropertyPrice.textContent = space.price;
            modalPropertyOwner.textContent = space.owner !== null ? players[space.owner].name : 'Unowned';
            modalPropertyMortgaged.textContent = space.mortgaged ? 'Yes' : 'No';
            modalPropertyMortgageValue.textContent = space.price / 2;

            // Clear previous color bar classes
            modalPropertyColorBar.className = 'color-bar';
            if (space.colorGroup) {
                modalPropertyColorBar.classList.add(space.colorGroup);
            } else {
                modalPropertyColorBar.style.backgroundColor = 'transparent'; // No color for railroads/utilities
            }

            modalPropertyRentList.innerHTML = ''; // Clear previous rent list

            if (space.type === 'property') {
                modalPropertyHousesRow.style.display = 'block';
                modalPropertyHouseCostRow.style.display = 'block';
                modalPropertyHouses.textContent = space.houses === 5 ? 'Hotel' : space.houses;
                modalPropertyHouseCost.textContent = space.houseCost;

                modalPropertyRentList.innerHTML += `<li><strong>Rent:</strong> $${space.rent[0]}</li>`;
                modalPropertyRentList.innerHTML += `<li>With 1 House: $${space.rent[1]}</li>`;
                modalPropertyRentList.innerHTML += `<li>With 2 Houses: $${space.rent[2]}</li>`;
                modalPropertyRentList.innerHTML += `<li>With 3 Houses: $${space.rent[3]}</li>`;
                modalPropertyRentList.innerHTML += `<li>With 4 Houses: $${space.rent[4]}</li>`;
                modalPropertyRentList.innerHTML += `<li>With HOTEL: $${space.rent[5]}</li>`;
            } else if (space.type === 'railroad') {
                modalPropertyHousesRow.style.display = 'none';
                modalPropertyHouseCostRow.style.display = 'none';
                modalPropertyRentList.innerHTML += `<li><strong>Rent (1 RR):</strong> $${space.rent[0]}</li>`;
                modalPropertyRentList.innerHTML += `<li><strong>Rent (2 RR):</strong> $${space.rent[1]}</li>`;
                modalPropertyRentList.innerHTML += `<li><strong>Rent (3 RR):</strong> $${space.rent[2]}</li>`;
                modalPropertyRentList.innerHTML += `<li><strong>Rent (4 RR):</strong> $${space.rent[3]}</li>`;
            } else if (space.type === 'utility') {
                modalPropertyHousesRow.style.display = 'none';
                modalPropertyHouseCostRow.style.display = 'none';
                modalPropertyRentList.innerHTML += `<li><strong>Rent (1 Utility):</strong> 4 times amount shown on dice</li>`;
                modalPropertyRentList.innerHTML += `<li><strong>Rent (2 Utilities):</strong> 10 times amount shown on dice</li>`;
            }

            propertyModalOverlay.style.display = 'flex'; // Show the modal
        }

        function hidePropertyModal() {
            propertyModalOverlay.style.display = 'none';
        }


        // --- Event Listeners ---
        numPlayersInput.addEventListener('change', () => {
            const num = parseInt(numPlayersInput.value);
            playerNameInputsDiv.innerHTML = '';
            for (let i = 0; i < num; i++) {
                const group = document.createElement('div');
                group.className = 'player-input-group';
                group.innerHTML = `<label for="player-name-${i}">Player ${i + 1} Name:</label>
                                   <input type="text" id="player-name-${i}" value="Player ${i + 1}">`;
                playerNameInputsDiv.appendChild(group);
            }
        });

        startGameBtn.addEventListener('click', startGame);
        rollDiceBtn.addEventListener('click', () => rollDice()); // Call rollDice without arguments for random roll
        endTurnBtn.addEventListener('click', endTurn);

        mortgagePropertyBtn.addEventListener('click', () => {
            const propId = parseInt(mortgageSelect.value);
            if (propId) mortgageProperty(players[currentPlayerIndex], propId);
        });
        unmortgagePropertyBtn.addEventListener('click', () => {
            const propId = parseInt(unmortgageSelect.value);
            if (propId) unmortgageProperty(players[currentPlayerIndex], propId);
        });
        sellHouseBtn.addEventListener('click', () => {
            const propId = parseInt(sellHouseSelect.value);
            if (propId) sellHouse(players[currentPlayerIndex], propId);
        });

        payBailBtn.addEventListener('click', () => {
            const player = players[currentPlayerIndex];
            if (player.inJail && player.money >= 50) {
                player.money -= 50;
                player.inJail = false;
                player.jailTurns = 0;
                logMessage(`${player.name} paid $50 bail to get out of Jail.`, 'success');
                updatePlayerInfo();
                setControlsForTurnStart(); 
            } else {
                logMessage("Not enough money to pay bail.", "error");
            }
        });

        useJailCardBtn.addEventListener('click', () => {
            const player = players[currentPlayerIndex];
            if (player.inJail && player.getOutOfJailFreeCards > 0) {
                player.getOutOfJailFreeCards--;
                player.inJail = false;
                player.jailTurns = 0;
                logMessage(`${player.name} used a Get Out of Jail Free card to get out of Jail!`, 'success');
                updatePlayerInfo();
                setControlsForTurnStart(); 
            } else {
                logMessage("No Get Out of Jail Free cards available.", "error");
            }
        });

        // Event listener for clicking on board spaces to show property info
        gameBoardDiv.addEventListener('click', (event) => {
            const clickedSpace = event.target.closest('.board-space');
            if (clickedSpace && clickedSpace.dataset.spaceId) {
                const spaceId = parseInt(clickedSpace.dataset.spaceId);
                showPropertyModal(spaceId);
            }
        });

        // Event listeners for closing the modal
        propertyModalCloseBtn.addEventListener('click', hidePropertyModal);
        propertyModalOverlay.addEventListener('click', (event) => {
            // Close if clicking on the overlay itself, not the content
            if (event.target === propertyModalOverlay) {
                hidePropertyModal();
            }
        });


        // Initial setup for player name inputs
        numPlayersInput.dispatchEvent(new Event('change'));


        // --- Debug Utility Functions ---

        function populateDebugPlayerSelects() {
            const playerOptions = players.map(p => `<option value="${p.id}">${p.name}</option>`).join('');
            debugMovePlayerSelect.innerHTML = `<option value="">-- Select Player --</option>` + playerOptions;
            debugJailPlayerSelect.innerHTML = `<option value="">-- Select Player --</option>` + playerOptions;
            debugOwnerSelect.innerHTML = `<option value="">-- Select Owner --</option><option value="bank">Bank</option>` + playerOptions;
        }

        function populateDebugSpaceSelect() {
            const spaceOptions = board.map(s => `<option value="${s.id}">${s.name} (ID: ${s.id})</option>`).join('');
            debugMoveSpaceSelect.innerHTML = `<option value="">-- Select Space --</option>` + spaceOptions;
        }

        function populateDebugPropertySelects() {
            const propertyOptions = board.filter(s => ['property', 'railroad', 'utility'].includes(s.type))
                                        .map(s => `<option value="${s.id}">${s.name}</option>`).join('');
            debugPropertySelect.innerHTML = `<option value="">-- Select Property --</option>` + propertyOptions;

            const housePropertyOptions = board.filter(s => s.type === 'property')
                                            .map(s => `<option value="${s.id}">${s.name}</option>`).join('');
            debugHousePropertySelect.innerHTML = `<option value="">-- Select Property --</option>` + housePropertyOptions;
        }

        function refreshDebugControls() {
            populateDebugPlayerSelects();
            populateDebugSpaceSelect();
            populateDebugPropertySelects();
        }

        // --- Debug Control Logic ---

        // Toggle Debug Controls Visibility
        toggleDebugBtn.addEventListener('click', () => {
            if (debugControlsDiv.style.display === 'none') {
                debugControlsDiv.style.display = 'flex'; // Use flex to apply inner styling
                refreshDebugControls(); // Populate dropdowns when shown
            } else {
                debugControlsDiv.style.display = 'none';
            }
        });

        // Debug Move Player
        debugMoveBtn.addEventListener('click', () => {
            const playerId = parseInt(debugMovePlayerSelect.value);
            const spaceId = parseInt(debugMoveSpaceSelect.value);

            if (isNaN(playerId) || isNaN(spaceId)) {
                logMessage("Please select a player and a space to move.", "error");
                return;
            }

            const player = players.find(p => p.id === playerId);
            if (!player) {
                logMessage("Player not found.", "error");
                return;
            }

            // Reset player's jail status if they were in jail and moved
            if (player.inJail && spaceId !== 10) { // If moving out of jail space
                player.inJail = false;
                player.jailTurns = 0;
                logMessage(`DEBUG: ${player.name} moved out of Jail.`, 'debug');
            }

            player.position = spaceId;
            logMessage(`DEBUG: ${player.name} moved directly to ${board[spaceId].name}.`, 'debug');
            updatePlayerInfo();
            updateBoardUI();
            landOnSpace(player); // Trigger landOnSpace logic for the new position
        });

        // Simulate Dice Roll button now calls the main rollDice function
        debugRollBtn.addEventListener('click', () => {
            const die1 = parseInt(debugDie1Input.value);
            const die2 = parseInt(debugDie2Input.value);

            if (isNaN(die1) || isNaN(die2) || die1 < 1 || die1 > 6 || die2 < 1 || die2 > 6) {
                logMessage("Please enter valid dice values (1-6).", "error");
                return;
            }

            // Call the main rollDice function with the simulated values
            rollDice(die1, die2);
            logMessage(`DEBUG: Simulated roll of ${die1}, ${die2}.`, 'debug');
        });

        // Change Property Ownership
        debugChangeOwnerBtn.addEventListener('click', () => {
            const propId = parseInt(debugPropertySelect.value);
            const ownerValue = debugOwnerSelect.value; // Can be player ID or "bank"

            if (isNaN(propId) || !ownerValue) {
                logMessage("Please select a property and an owner.", "error");
                return;
            }

            const property = board[propId];
            if (!property || !['property', 'railroad', 'utility'].includes(property.type)) {
                logMessage("Selected space is not a property, railroad, or utility.", "error");
                return;
            }

            // Remove from old owner's properties
            if (property.owner !== null) {
                const oldOwner = players.find(p => p.id === property.owner);
                if (oldOwner) {
                    oldOwner.properties = oldOwner.properties.filter(p => p !== propId);
                    // If property had houses, they are removed when ownership changes
                    if (property.type === 'property') {
                        oldOwner.money += property.houses * (property.houseCost / 2); // Refund half cost
                        logMessage(`DEBUG: ${oldOwner.name} refunded $${property.houses * (property.houseCost / 2)} for houses on ${property.name}.`, 'debug');
                        property.houses = 0;
                    }
                    property.mortgaged = false; // Unmortgage when ownership changes
                }
            }

            // Assign to new owner
            if (ownerValue === 'bank') {
                property.owner = null;
                logMessage(`DEBUG: ${property.name} is now unowned (Bank).`, 'debug');
            } else {
                const newOwnerId = parseInt(ownerValue);
                const newOwner = players.find(p => p.id === newOwnerId);
                if (newOwner) {
                    property.owner = newOwnerId;
                    newOwner.properties.push(propId);
                    logMessage(`DEBUG: ${property.name} is now owned by ${newOwner.name}.`, 'debug');
                } else {
                    logMessage("New owner not found.", "error");
                    return;
                }
            }

            updatePlayerInfo();
            updateBoardUI();
        });

        // Set Houses/Hotels
        debugSetHousesBtn.addEventListener('click', () => {
            const propId = parseInt(debugHousePropertySelect.value);
            const houseCount = parseInt(debugHouseCountInput.value);

            if (isNaN(propId) || isNaN(houseCount) || houseCount < 0 || houseCount > 5) {
                logMessage("Please select a property and a valid house count (0-5).", "error");
                return;
            }

            const property = board[propId];
            if (!property || property.type !== 'property') {
                logMessage("Selected space is not a buildable property.", "error");
                return;
            }

            if (property.owner === null) {
                logMessage("Property must be owned to set houses.", "error");
                return;
            }

            // For debugging, we'll bypass money/monopoly checks for simplicity.
            // In a real game, you'd enforce these.
            property.houses = houseCount;
            logMessage(`DEBUG: Set ${property.name} to ${houseCount} houses/hotel.`, 'debug');
            updatePlayerInfo();
            updateBoardUI();
        });

        // Put Player in Jail
        debugSendToJailBtn.addEventListener('click', () => {
            const playerId = parseInt(debugJailPlayerSelect.value);

            if (isNaN(playerId)) {
                logMessage("Please select a player to send to jail.", "error");
                return;
            }

            const player = players.find(p => p.id === playerId);
            if (!player) {
                logMessage("Player not found.", "error");
                return;
            }

            sendToJail(player); // Use the existing game function
            logMessage(`DEBUG: ${player.name} sent to Jail.`, 'debug');
            updatePlayerInfo();
            updateBoardUI();
        });

    </script>
</body>
</html>